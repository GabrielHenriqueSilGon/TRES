# LabirintoA
 
Para esse problema, foi desenvolvido um algoritmo que encontra o caminho em um labirinto quadrado utilizando as funções de Manhattan e de Euristica. Este algoritmo utilizou como base o algoritmo bfs, logo possui muitos de seus inputs e funções. Ao compilar o algoritmo, este pede como input inicial o número de linhas e colunas do labirinto, e a seguir pede uma escolha entre o algoritmo de Manhattan ou Euristica. Após informados, a função "create" que faz o labirinto é chamada. Para modificar os bloqueios no labirinto, usa-se um vetor de pairs que devem ser editados no cpp para trocar os bloqueios no labirinto em si, assim como o número de bloqueios que é usado para deixar mais polido o algoritmo "create". A função "create"  então cria uma matriz de ints, colocando 0's nos espaços vazios e 1 nos bloqueios. Outra função chamada "mostra" lê e imprime a matriz, além de formata-la a um aspecto mais amigável que vários zeros e uns. Zeros aparecem como espaços vazios e uns como "x" para marcar bloqueios. Esta também troca -1 por "o", mas esse método só aparece no fim da compilação. Após imprimir a matriz original, o método "CaminhoA" tenta sair de [0,0] e chegar a [n-1,n-1] na matriz, este faz isso por meio de uma lista formada do type Ppairs, que é um pair { double, pair<int,int>} que guarda as coordenadas visitadas assim como seu "peso", e um laço de repetição while que dura até o caminho chegar a [n-1,n-1] que envia o local atual a uma função "Proximo" que compara os pesos de cada caminho possível e segue pelo menor de acordo com o algoritmo escolhido.

Agora, para compararmos os três algoritmos de labirinto programados, vamos realizar alguns testes. A principio vamos começar com um caminho livre de obstáculos. Numa matriz de tamanho 6, o BFS encontra o caminho até o final em 10 iterações, o DFS encontra em 10 iterações, a euclidiana encontra em 10 iterações e utilizando Manhattan, A* encontra o caminho com o mesmo caminho e número de iterações que o BFS. 

A principio, todos os algoritmos apresentam a mesma velocidade de execução, baseando-se apenas nas iterações realizadas, mas ao adicionar obstáculos em [2,3][3,3][4,3][5,3][1,5] e [2,5], em um labirinto de tamanho 6, podemos testar melhor cada método. No DFS, se leva 18 iterações para encontrar o caminho, no BFS e em Manhattan levam 11, mas já a euclidiana leva 23. Isso nos leva a pensar que a euclidiana não é muito boa, mas quando movemos os 4 primeiros bloqueios para a coluna 1, a euclidiana passa a ser o método com menos iterações. Em resumo, a melhor formula depende muito dos bloqueios.